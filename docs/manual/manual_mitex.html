

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>MitEx &mdash; qermit-manual  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="_static/thebelab.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/thebelab-helper.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="MitRes" href="manual_mitres.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> qermit-manual
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="manual_intro.html">What is qermit?</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual_mitres.html">MitRes</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">MitEx</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#error-mitigation-with-mitex">Error-mitigation with <code class="docutils literal notranslate"><span class="pre">MitEx</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#extending-mitex-with-mittask">Extending <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> with <code class="docutils literal notranslate"><span class="pre">MitTask</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#probabilistic-error-cancellation-in-qermit">Probabilistic-Error-Cancellation in <code class="docutils literal notranslate"><span class="pre">qermit</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#zero-noise-extrapolation-in-qermit">Zero-Noise-Extrapolation in <code class="docutils literal notranslate"><span class="pre">qermit</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#clifford-circuit-learning-and-clifford-data-regression-in-qermit">Clifford-Circuit-Learning and Clifford-Data-Regression in <code class="docutils literal notranslate"><span class="pre">qermit</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#depolarisation-factor-supression-for-nearest-clifford-in-qermit">Depolarisation-Factor-Supression-For-Nearest-Clifford in <code class="docutils literal notranslate"><span class="pre">qermit</span></code></a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">qermit-manual</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>MitEx</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/manual_mitex.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mitex">
<h1>MitEx<a class="headerlink" href="#mitex" title="Permalink to this headline">¶</a></h1>
<p>A core process of many NISQ applications, such as variational algorithms, is the evaluation of the
average value of observables for some circuit. This corresponds to measuring the expected value of
the bit strings returned by measured qubit shots.</p>
<p>During a typical flow one: defines an ansatz circuit and an observable,
produces an appropriate set of measurement circuits, executes all these measurement circuits
on a device, calculates their expectation values,
and then modifies them by some coefficients, leaving an estimation of the expectation value of the observable.</p>
<p>In its basic capacity, the <code class="docutils literal notranslate"><span class="pre">MitEx.run</span></code> <a class="reference external" href="https://cqcl.github.io/qermit/mitex.html">method</a> will run each of these
tasks sequentially, automating the procedure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qermit</span> <span class="kn">import</span> <span class="n">MitEx</span>
<span class="kn">from</span> <span class="nn">pytket.extensions.qiskit</span> <span class="kn">import</span> <span class="n">AerBackend</span>

<span class="n">mitex</span> <span class="o">=</span> <span class="n">MitEx</span><span class="p">(</span><span class="n">backend</span> <span class="o">=</span> <span class="n">AerBackend</span><span class="p">())</span>
<span class="n">mitex</span><span class="o">.</span><span class="n">get_task_graph</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/mitex_taskgraph.png" src="_images/mitex_taskgraph.png" />
<p>While the arguments to <code class="docutils literal notranslate"><span class="pre">MitRes</span></code> will be intuitive to anyone who has used <code class="docutils literal notranslate"><span class="pre">pytket</span></code> before, the arguments
to <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> may require more consideration (though hopefully sensical to someone who has run an experiment estimating
the expectation of an observable before, such as a Variational Quantum Eigensolver experiment).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">MitEx.run</span></code> method takes <code class="docutils literal notranslate"><span class="pre">List[ObservableExperiment]</span></code> as an argument, and returns <code class="docutils literal notranslate"><span class="pre">List[QubitPauliOperator]</span></code>.
An <code class="docutils literal notranslate"><span class="pre">ObservableExperiment</span></code> is a type defined to include the miniumum amount of information necessary to estimate
an observable with error-mitigation. <code class="docutils literal notranslate"><span class="pre">ObservableExperiment</span></code> is a <code class="docutils literal notranslate"><span class="pre">namedtuple</span></code> with two elements, an <code class="docutils literal notranslate"><span class="pre">AnsatzCircuit</span></code> and an <code class="docutils literal notranslate"><span class="pre">ObservableTracker</span></code>.</p>
<p>An <code class="docutils literal notranslate"><span class="pre">AnsatzCircuit</span></code> <code class="docutils literal notranslate"><span class="pre">Tuple</span></code> has three elements, a <code class="docutils literal notranslate"><span class="pre">Circuit</span></code>, the number of device shots to take of <code class="docutils literal notranslate"><span class="pre">Circuit</span></code>
when running on a device, and a <code class="docutils literal notranslate"><span class="pre">SymbolsDict</span></code> holding a dictionary between symbolic parameters in the <code class="docutils literal notranslate"><span class="pre">Circuit</span></code> and
parameters to subsitute them with. The <code class="docutils literal notranslate"><span class="pre">Circuit</span></code> object should have no <code class="docutils literal notranslate"><span class="pre">Measure</span></code> gates, as these will be added
during <code class="docutils literal notranslate"><span class="pre">qermit</span></code> runtime as measurement circuits are produced.</p>
<p>Note that currently <code class="docutils literal notranslate"><span class="pre">qermit</span></code> can not run variational experiments, but a collection of
experiments with different parameters can be passed to <code class="docutils literal notranslate"><span class="pre">MitEx.run</span></code> at the same time, and the same error-mitigation
characteriastions will be used for different experiments where possible.</p>
<p><a class="reference external" href="https://cqcl.github.io/pytket/build/html/utils.html?highlight=qubitpaulioperator#pytket.utils.QubitPauliOperator">QubitPauliOperator</a> is
a generic data structure from <code class="docutils literal notranslate"><span class="pre">pytket</span></code> that contains a dictionary from <code class="docutils literal notranslate"><span class="pre">QubitPauliString</span></code> to
a float (for <code class="docutils literal notranslate"><span class="pre">qermit</span></code> usage). A <a class="reference external" href="https://cqcl.github.io/pytket/build/html/pauli.html?highlight=qubitpaulistring#pytket.pauli.QubitPauliString">QubitPauliString</a>
is a string of Pauli letters (as used to define Observables to be measured), indexed by a <code class="docutils literal notranslate"><span class="pre">Pytket</span></code> <code class="docutils literal notranslate"><span class="pre">Qubit</span></code>.</p>
<p>Finally, an <code class="docutils literal notranslate"><span class="pre">ObservableTracker</span></code> is an object defined by a <code class="docutils literal notranslate"><span class="pre">QubitPauliOperator</span></code> that keeps track of both
the observable being measured and the measurement circuits required to do so.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qermit</span> <span class="kn">import</span> <span class="n">AnsatzCircuit</span><span class="p">,</span> <span class="n">SymbolsDict</span>
<span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">fresh_symbol</span>

<span class="n">sym</span> <span class="o">=</span> <span class="n">fresh_symbol</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">300</span>
<span class="n">symbols</span> <span class="o">=</span> <span class="n">SymbolsDict</span><span class="o">.</span><span class="n">symbols_from_dict</span><span class="p">({</span><span class="n">test</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">})</span>
<span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">AnsatzCircuit</span><span class="p">(</span><span class="n">Circuit</span><span class="o">=</span><span class="n">circuit</span><span class="p">,</span> <span class="n">Shots</span><span class="o">=</span><span class="n">shots</span><span class="p">,</span> <span class="n">SymbolsDict</span><span class="o">=</span><span class="n">symbols</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AnsatzCircuit</span><span class="p">(</span><span class="n">Circuit</span><span class="o">=</span><span class="p">[</span><span class="n">X</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">X</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">Rz</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="p">],</span> <span class="n">Shots</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">SymbolsDict</span><span class="o">=&lt;</span><span class="n">SymbolsDict</span><span class="p">::</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Qubit</span>
<span class="kn">from</span> <span class="nn">pytket.pauli</span> <span class="kn">import</span> <span class="n">Pauli</span><span class="p">,</span> <span class="n">QubitPauliString</span>
<span class="kn">from</span> <span class="nn">pytket.utils</span> <span class="kn">import</span> <span class="n">QubitPauliOperator</span>

<span class="n">qubit_pauli_string</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">])</span>
<span class="n">qubit_pauli_operator</span> <span class="o">=</span> <span class="n">QubitPauliOperator</span><span class="p">({</span><span class="n">qubit_pauli_string</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>

<span class="nb">print</span><span class="p">(</span><span class="n">qubit_pauli_operator</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{(</span><span class="n">Zq</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Zq</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span> <span class="mf">1.00000000000000</span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qermit</span> <span class="kn">import</span> <span class="n">ObservableTracker</span>

<span class="n">observable_tracker</span> <span class="o">=</span> <span class="n">ObservableTracker</span><span class="p">(</span><span class="n">qubit_pauli_operator</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">observable_tracker</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ObservableTracker</span><span class="p">::</span><span class="mi">0</span><span class="n">MeasurementCircuits</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MitEx</span></code> will produce and keep track of measurement circuits as it runs, we simply need to construct the object from a <code class="docutils literal notranslate"><span class="pre">QubitPauliOperator</span></code> as an argument.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qermit</span> <span class="kn">import</span> <span class="n">ObservableExperiment</span>

<span class="n">observable_experiment</span> <span class="o">=</span> <span class="n">ObservableExperiment</span><span class="p">(</span><span class="n">AnsatzCircuit</span> <span class="o">=</span> <span class="n">ansatz_circuit</span><span class="p">,</span> <span class="n">ObservableTracker</span> <span class="o">=</span> <span class="n">observable_tracker</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">observable_experiment</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ObservableExperiment</span><span class="p">(</span><span class="n">AnsatzCircuit</span><span class="o">=</span><span class="n">AnsatzCircuit</span><span class="p">(</span><span class="n">Circuit</span><span class="o">=</span><span class="p">[</span><span class="n">X</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">X</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">Rz</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="p">],</span> <span class="n">Shots</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">SymbolsDict</span><span class="o">=&lt;</span><span class="n">SymbolsDict</span><span class="p">::</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">ObservableTracker</span><span class="o">=&lt;</span><span class="n">ObservableTracker</span><span class="p">::</span><span class="mi">0</span><span class="n">MeasurementCircuits</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">MitEx.run</span></code> method takes <code class="docutils literal notranslate"><span class="pre">List[ObservableExperiment]</span></code> as an argument, each <code class="docutils literal notranslate"><span class="pre">ObservableExperiment</span></code> representing
a different estimation for a different circuit. For each <code class="docutils literal notranslate"><span class="pre">ObservableExperiment</span></code> a <code class="docutils literal notranslate"><span class="pre">QubitPauliOperator</span></code> is returned, giving
the expectation value for each <code class="docutils literal notranslate"><span class="pre">QubitPauliString</span></code> in the operator.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">mitex</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">observable_experiment</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{(</span><span class="n">Zq</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Zq</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span> <span class="o">-</span><span class="mf">1.00000000000000</span><span class="p">}]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> constructor has a <code class="docutils literal notranslate"><span class="pre">mitres</span></code> keyword, which if passed a <code class="docutils literal notranslate"><span class="pre">MitRes</span></code> object will construct the resulting <code class="docutils literal notranslate"><span class="pre">MitEx</span></code>
from it. This is similar in spirit to the combining of error-mitigation methods discussed in “Combining <code class="docutils literal notranslate"><span class="pre">MitRes</span></code> methods”.</p>
<div class="section" id="error-mitigation-with-mitex">
<h2>Error-mitigation with <code class="docutils literal notranslate"><span class="pre">MitEx</span></code><a class="headerlink" href="#error-mitigation-with-mitex" title="Permalink to this headline">¶</a></h2>
<p>As with <code class="docutils literal notranslate"><span class="pre">MitRes</span></code>, to produce a <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object that executes an error-mitigation
protocol when <code class="docutils literal notranslate"><span class="pre">MitEx.run</span></code> is called, additional <code class="docutils literal notranslate"><span class="pre">MitTask</span></code> objects need to be added
to the task graph.</p>
<p>The defining characteristic of a <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object is that the first <code class="docutils literal notranslate"><span class="pre">MitTask</span></code> object
in its sorted graph requires a <code class="docutils literal notranslate"><span class="pre">List[ObservableExperiment]</span></code> object as its sole argument and that
the final <code class="docutils literal notranslate"><span class="pre">MitTask</span></code> object in its sorted graph returns a <code class="docutils literal notranslate"><span class="pre">List[QubitPauliOperator]</span></code> object.
As with <code class="docutils literal notranslate"><span class="pre">MitRes</span></code>, this is a crucial type constraint required for the combining of error-mitigation methods.</p>
<p>Once more, there are two viable approaches for producing error-mitigation <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> objects, either
extending a <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object with new <code class="docutils literal notranslate"><span class="pre">MitTask</span></code> objects under strict type constraints, or constructing
a <code class="docutils literal notranslate"><span class="pre">TaskGraph</span></code> object with relaxed type constraints on internal tasks and then casting to a <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object at completion.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">MitRes</span></code> section of the manual explains constructing a <code class="docutils literal notranslate"><span class="pre">TaskGraph</span></code> in great detail and as the process
is nearly identical for <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> we will not explain this again here - if you are interested please refer to that section
of the manual. However, we will consider extending a <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object with new <code class="docutils literal notranslate"><span class="pre">MitTask</span></code> objects so as
to show the type constraints explicitly.</p>
</div>
<div class="section" id="extending-mitex-with-mittask">
<h2>Extending <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> with <code class="docutils literal notranslate"><span class="pre">MitTask</span></code><a class="headerlink" href="#extending-mitex-with-mittask" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">MitEx.append</span></code> and <code class="docutils literal notranslate"><span class="pre">MitEx.prepend</span></code> methods can be used to extend the
<code class="docutils literal notranslate"><span class="pre">MitTask</span></code> objects the <code class="docutils literal notranslate"><span class="pre">MitEx._task_graph</span></code> attribute holds.</p>
<p>In some estimation experiments, a priori knowledge about the circuit structure and observable measured can be utilised to discard Shots.
This can happen when, for example, some combination of Bits has a value which is known to be impossible. An example
of a formal approach to such a method is <em>symmetry verification</em> <a class="reference internal" href="#bonet-monroig2018" id="id1"><span>[Bonet-Monroig2018]</span></a>.</p>
<p>As an example, let’s construct a <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object that performs a very basic version of this. While this example
will lack physical meaning, it will display how such a method could be written.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qermit</span> <span class="kn">import</span> <span class="n">MitTask</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Bit</span>

<span class="k">def</span> <span class="nf">add_ancillas_task_gen</span><span class="p">(</span><span class="n">ancillas</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Qubit</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">,</span> <span class="n">Bit</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">MitTask</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">task</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">experiment_wire</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ObservableExperiment</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">ObservableExperiment</span><span class="p">]]:</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">experiment_wire</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">AnsatzCircuit</span><span class="o">.</span><span class="n">Circuit</span>
            <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">ancillas</span><span class="p">:</span>
                <span class="n">q0</span> <span class="o">=</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">q1</span> <span class="o">=</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                <span class="c1"># check tup is compatible with circuit</span>
                <span class="n">circuit_qubits</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">AnsatzCircuit</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">qubits</span>
                <span class="k">if</span> <span class="n">q0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">circuit_qubits</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Circuit has no qubit </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">q0</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">q1</span> <span class="ow">in</span> <span class="n">circuit_qubits</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Circuit already has ancilla qubit </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">q1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">entry</span><span class="o">.</span><span class="n">AnsatzCircuit</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">bits</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Circuit already had bit </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
                <span class="c1"># add new Qubit, add CX between control and ancilla, add Measure</span>
                <span class="n">c</span><span class="o">.</span><span class="n">add_qubit</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">add_bit</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">experiment_wire</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">MitTask</span><span class="p">(</span><span class="n">_label</span><span class="o">=</span><span class="s2">&quot;AddMeasureAncillas&quot;</span><span class="p">,</span> <span class="n">_n_in_wires</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">_n_out_wires</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">_method</span><span class="o">=</span><span class="n">task</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">add_ancillas_task_gen</span></code> function returns a <code class="docutils literal notranslate"><span class="pre">MitTask</span></code> that modifies the <code class="docutils literal notranslate"><span class="pre">AnsatzCircuit.Circuit</span></code> to some specification,
adding measured ancilla <code class="docutils literal notranslate"><span class="pre">Qubit</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ancillas</span> <span class="o">=</span> <span class="p">[(</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">Bit</span><span class="p">(</span><span class="mi">3</span><span class="p">))]</span>
<span class="n">ancillas_task</span> <span class="o">=</span> <span class="n">add_ancillas_task_gen</span><span class="p">(</span><span class="n">ancillas</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ancillas_task</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">MitTask</span><span class="p">::</span><span class="n">AddMeasureAncillas</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sim_backend</span> <span class="o">=</span> <span class="n">AerBackend</span><span class="p">()</span>
<span class="n">mitex_discard</span> <span class="o">=</span> <span class="n">MitEx</span><span class="p">(</span><span class="n">backend</span> <span class="o">=</span> <span class="n">sim_backend</span><span class="p">)</span>
<span class="n">mitex_discard</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">ancillas_task</span><span class="p">)</span>
<span class="n">mitex</span><span class="o">.</span><span class="n">get_task_graph</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/ancilla_mitex_taskgraph.png" src="_images/ancilla_mitex_taskgraph.png" />
<p>Clearly this <code class="docutils literal notranslate"><span class="pre">MitTask</span></code> needs a later corresponding task to process these results. As mentioned earlier,
the <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> constructor accepts a <code class="docutils literal notranslate"><span class="pre">MitRes</span></code> object from which it constructs its task graph. We can prepare
a <code class="docutils literal notranslate"><span class="pre">MitTask</span></code> that modifies <code class="docutils literal notranslate"><span class="pre">BackendResult</span></code> given a configuration related to <code class="docutils literal notranslate"><span class="pre">ancillas_task</span></code> and then prepend
it to the <code class="docutils literal notranslate"><span class="pre">MitRes</span></code> object used for constructing the <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.backends.backendresult</span> <span class="kn">import</span> <span class="n">BackendResult</span>
<span class="kn">from</span> <span class="nn">pytket.utils.outcomearray</span> <span class="kn">import</span> <span class="n">OutcomeArray</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="k">def</span> <span class="nf">discard_counts_task_gen</span><span class="p">(</span><span class="n">to_discard</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Bit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">MitTask</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">task</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">BackendResult</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">BackendResult</span><span class="p">]]:</span>
        <span class="n">updated_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">to_discard</span><span class="p">:</span>
                <span class="n">bit</span> <span class="o">=</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># find entry in counts that corresponds to bit of choice</span>
                <span class="n">count_index</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">c_bits</span><span class="p">[</span><span class="n">bit</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
                    <span class="c1"># bit of returned state is banned type</span>
                    <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="n">count_index</span><span class="p">]</span> <span class="o">==</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="c1"># remove all counts for banned state</span>
                        <span class="n">counts</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># convert updated Counter to a BackendResult object, add to new results</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="n">OutcomeArray</span><span class="o">.</span><span class="n">from_readouts</span><span class="p">([</span><span class="n">key</span><span class="p">]):</span> <span class="n">val</span>
                    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="n">updated_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">BackendResult</span><span class="p">(</span><span class="n">c_bits</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">c_bits</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">counter</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">updated_results</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">MitTask</span><span class="p">(</span><span class="n">_label</span><span class="o">=</span><span class="s2">&quot;DiscardCountsTask&quot;</span><span class="p">,</span> <span class="n">_n_in_wires</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">_n_out_wires</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">_method</span><span class="o">=</span><span class="n">task</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">discard_counts_task_gen</span></code> function returns a <code class="docutils literal notranslate"><span class="pre">MitTask</span></code> object that assigns some counts results
in <code class="docutils literal notranslate"><span class="pre">BackendResult</span></code> to 0 if their Bitstring has some Bit in a specific state.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">discard_task</span> <span class="o">=</span> <span class="n">discard_counts_task_gen</span><span class="p">([(</span><span class="n">Bit</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">discard_task</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">MitTask</span><span class="p">::</span><span class="n">DiscardCountsTask</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qermit.taskgraph</span> <span class="kn">import</span> <span class="n">backend_compile_circuit_shots_task_gen</span>


<span class="n">mitres_discard</span> <span class="o">=</span> <span class="n">MitRes</span><span class="p">(</span><span class="n">backend</span> <span class="o">=</span> <span class="n">sim_backend</span><span class="p">)</span>
<span class="n">mitres_discard</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">discard_task</span><span class="p">)</span>
<span class="n">mitres_discard</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">backend_compile_circuit_shots_task_gen</span><span class="p">(</span><span class="n">sim_backend</span><span class="p">,</span> <span class="n">optimisation_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">mitres_discard</span><span class="o">.</span><span class="n">get_task_graph</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/discard_mitres_taskgraph.png" src="_images/discard_mitres_taskgraph.png" />
<p>Lets create a new <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object constructed from <code class="docutils literal notranslate"><span class="pre">mitres_discard</span></code> and then test it.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">combined_mitex</span> <span class="o">=</span> <span class="n">MitEx</span><span class="p">(</span><span class="n">sim_backend</span><span class="p">,</span> <span class="n">mitres</span> <span class="o">=</span> <span class="n">mitres_discard</span><span class="p">)</span>
<span class="n">combined_mitex</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">add_ancillas_task_gen</span><span class="p">([(</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">Bit</span><span class="p">(</span><span class="mi">3</span><span class="p">))])</span>
<span class="n">combined_mitex</span><span class="o">.</span><span class="n">decompose_TaskGraph_nodes</span><span class="p">()</span>
<span class="n">combined_mitex</span><span class="o">.</span><span class="n">get_task_graph</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/combined_mitex_taskgraph.png" src="_images/combined_mitex_taskgraph.png" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sym_discard</span> <span class="o">=</span> <span class="n">fresh_symbol</span><span class="p">(</span><span class="s2">&quot;discard_test&quot;</span><span class="p">)</span>
<span class="n">circuit_discard</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="n">sym_discard</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">symbols</span> <span class="o">=</span> <span class="n">SymbolsDict</span><span class="o">.</span><span class="n">symbols_from_dict</span><span class="p">({</span><span class="n">sym_discard</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">})</span>
<span class="n">ansatz_circuit_discard</span> <span class="o">=</span> <span class="n">AnsatzCircuit</span><span class="p">(</span><span class="n">Circuit</span><span class="o">=</span><span class="n">circuit_discard</span><span class="p">,</span> <span class="n">Shots</span><span class="o">=</span><span class="n">shots</span><span class="p">,</span> <span class="n">SymbolsDict</span><span class="o">=</span><span class="n">symbols</span><span class="p">)</span>

<span class="n">qps</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">])</span>
<span class="n">qpo_discard</span> <span class="o">=</span> <span class="n">QubitPauliOperator</span><span class="p">({</span><span class="n">qps</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>

<span class="n">discard_results</span> <span class="o">=</span> <span class="n">discard_mitex</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">ObservableExperiment</span><span class="p">(</span><span class="n">ansatz_circuit_discard</span><span class="p">,</span> <span class="n">ObservableTracker</span><span class="p">(</span><span class="n">qpo_discard</span><span class="p">))])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">discard_results</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{(</span><span class="n">Zq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Zq</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Zq</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span> <span class="mf">1.00000000000000</span><span class="p">}]</span>
</pre></div>
</div>
<p>Without any modification, one would expect the Circuit and measured operator to return either (0,0,1) or (1,0,1)
with equal probability, giving a returned expectation value close to 0.
However, with the additional ancilla qubit and discarding task, all shots returning (1,0,1) are discarded,
leaving an expectation of 1 generated from (0,0,1) shots only.</p>
<p>Considering the <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> type constraints, we can also append <code class="docutils literal notranslate"><span class="pre">MitTask</span></code> that receive <code class="docutils literal notranslate"><span class="pre">List[QubitPauliOperator]</span></code> and
return <code class="docutils literal notranslate"><span class="pre">Tuple[List[QubitPauliOperator]]</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">modify_operator_task_gen</span><span class="p">(</span><span class="n">to_zero</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MitTask</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">task</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">QubitPauliOperator</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">QubitPauliOperator</span><span class="p">]]:</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="n">operator_dict</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">_dict</span>
            <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">operator_dict</span><span class="p">:</span>
                <span class="c1"># if absolute of value less than given value, set coefficient to zero</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">operator_dict</span><span class="p">[</span><span class="n">string</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">to_zero</span><span class="p">:</span>
                    <span class="n">operator_dict</span><span class="p">[</span><span class="n">string</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">results</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">MitTask</span><span class="p">(</span><span class="n">_label</span><span class="o">=</span><span class="s2">&quot;ModifyOperator&quot;</span><span class="p">,</span> <span class="n">_n_in_wires</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">_n_out_wires</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">_method</span> <span class="o">=</span> <span class="n">task</span><span class="p">)</span>
</pre></div>
</div>
<p>As a simple example, this task iterates through every value of every <code class="docutils literal notranslate"><span class="pre">QubitPauliOperator</span></code> and sets the value to 0
if its value is within some passed range. A more realistic example may modify the values give some characterisation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">discard_mitex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">modify_operator_task_gen</span><span class="p">(</span><span class="mf">0.1</span><span class="p">))</span>
<span class="n">discard_mitex</span><span class="o">.</span><span class="n">get_task_graph</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/combined_mitex_final_taskgraph.png" src="_images/combined_mitex_final_taskgraph.png" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">discard_mitex</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">ObservableExperiment</span><span class="p">(</span><span class="n">ansatz_circuit_discard</span><span class="p">,</span> <span class="n">ObservableTracker</span><span class="p">(</span><span class="n">qpo_discard</span><span class="p">))]))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{(</span><span class="n">Zq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Zq</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Zq</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span> <span class="mf">1.00000000000000</span><span class="p">}]</span>
</pre></div>
</div>
<p>Given our discarding tasks, the expectation value returned in this task is always 1.0.</p>
<p>There are several <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> error-mitigation methods available in <code class="docutils literal notranslate"><span class="pre">qermit</span></code>; Probabilistic-Error-Cancellation <a class="reference internal" href="#temme2016" id="id2"><span>[Temme2016]</span></a>,
Zero-Noise-Extrapolation <a class="reference internal" href="#giurgica-tiron2020" id="id3"><span>[Giurgica-Tiron2020]</span></a>, Clifford Data Regression with Clifford-Circuit-Learning <a class="reference internal" href="#czarnik2020" id="id4"><span>[Czarnik2020]</span></a>, and
Depolarisation-Factor-Supression-For-Nearest-Clifford (an internal method).
As with <code class="docutils literal notranslate"><span class="pre">MitRes</span></code>, each is available via a selection of generator functions.</p>
</div>
<div class="section" id="probabilistic-error-cancellation-in-qermit">
<h2>Probabilistic-Error-Cancellation in <code class="docutils literal notranslate"><span class="pre">qermit</span></code><a class="headerlink" href="#probabilistic-error-cancellation-in-qermit" title="Permalink to this headline">¶</a></h2>
<p>Probabilistic-Error-Cancellation (PEC), introduced in <a class="reference internal" href="#temme2016" id="id5"><span>[Temme2016]</span></a>, utilises that it is
possible to mitigate for the effect of errors by sampling from a set of erroneous circuits.
In particular, a linear combination of the expectation values of an observable measured
on a selection of circuit exposed to noise can give an error mitigated expectation value
of some fixed primary circuit. Typically this set of circuits is derived from the primary circuit by
the addition of certain gates, while the coefficients in the linear combination
depend on the noise channel.</p>
<p>If a precise characterisation of the noise model is available, then a means to arrive at
both the form and weighting of the set of quantum circuits which perfectly corrects for
this model is known <a class="reference internal" href="#endo2018" id="id6"><span>[Endo2018]</span></a> <a class="reference internal" href="#temme2016" id="id7"><span>[Temme2016]</span></a>. Unfortunately, such a characterisation can be
very costly to perform if more than a handful of qubits are involved.</p>
<p>To address this, <a class="reference internal" href="#strikis2020" id="id8"><span>[Strikis2020]</span></a> introduces a means to learn the appropriate weighting
of the noisy circuits. These coefficients are learnt by minimising the error in the final
expectation value. As the ideal expectation value of the primary circuit is not known,
the training is performed using Clifford circuits which are similar in form to the
primary circuit. The expectation of these Clifford circuits can be calculated efficiently
using a classical simulator, and so can be compared to the results from noisy runs.
It is on this approach that the implementation of PEC in <code class="docutils literal notranslate"><span class="pre">qermit</span></code> is based.</p>
<p>Generators for Probabilistic-Error-Cancellation <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> objects are available in
the  <code class="docutils literal notranslate"><span class="pre">qermit.probabilistic_error_cancellation</span></code> <a class="reference external" href="https://cqcl.github.io/qermit/probabilistic_error_cancellation.html">module</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qermit.probabilistic_error_cancellation</span> <span class="kn">import</span> <span class="n">gen_PEC_Mitex</span>
<span class="kn">from</span> <span class="nn">pytket.extensions.qiskit</span> <span class="kn">import</span> <span class="n">IBMQEmulatorBackend</span><span class="p">,</span> <span class="n">AerBackend</span>

<span class="n">pec_mitex</span> <span class="o">=</span> <span class="n">gen_PEC_MitEx</span><span class="p">(</span><span class="n">device_backend</span> <span class="o">=</span> <span class="n">casablanca_backend</span><span class="p">,</span> <span class="n">simulator_backend</span> <span class="o">=</span> <span class="n">noiseless_backend</span><span class="p">)</span>
<span class="n">pec_mitex</span><span class="o">.</span><span class="n">get_task_graph</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/PEC_taskgraph.png" src="_images/PEC_taskgraph.png" />
<p>Let’s construct a test case with expected value 1.0 and run the error-mitigation <code class="docutils literal notranslate"><span class="pre">MitEx</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">PauliExpBox</span><span class="p">,</span> <span class="n">Qubit</span>
<span class="kn">from</span> <span class="nn">pytket.passes</span> <span class="kn">import</span> <span class="n">DecomposeBoxes</span>
<span class="kn">from</span> <span class="nn">pytket.pauli</span> <span class="kn">import</span> <span class="n">Pauli</span><span class="p">,</span> <span class="n">QubitPauliString</span>
<span class="kn">from</span> <span class="nn">pytket.utils</span> <span class="kn">import</span> <span class="n">QubitPauliOperator</span>

<span class="kn">from</span> <span class="nn">qermit</span> <span class="kn">import</span> <span class="n">ObservableTracker</span><span class="p">,</span> <span class="n">AnsatzCircuit</span><span class="p">,</span> <span class="n">SymbolsDict</span><span class="p">,</span> <span class="n">ObservableExperiment</span>


<span class="n">peb_xyz</span> <span class="o">=</span> <span class="n">PauliExpBox</span><span class="p">([</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Y</span><span class="p">],</span> <span class="mf">0.25</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">DecomposeBoxes</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<span class="n">qubit_pauli_string</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">])</span>
<span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">AnsatzCircuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">SymbolsDict</span><span class="p">())</span>

<span class="n">exp</span> <span class="o">=</span> <span class="p">[</span><span class="n">ObservableExperiment</span><span class="p">(</span><span class="n">ansatz_circuit</span><span class="p">,</span> <span class="n">ObservableTracker</span><span class="p">(</span><span class="n">QubitPauliOperator</span><span class="p">({</span><span class="n">qubit_pauli_string</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})))]</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">pec_mitex</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{(</span><span class="n">Znode</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">Znode</span><span class="p">[</span><span class="mi">6</span><span class="p">]):</span> <span class="mf">1.01978876035084</span><span class="p">}]</span>
</pre></div>
</div>
</div>
<div class="section" id="zero-noise-extrapolation-in-qermit">
<h2>Zero-Noise-Extrapolation in <code class="docutils literal notranslate"><span class="pre">qermit</span></code><a class="headerlink" href="#zero-noise-extrapolation-in-qermit" title="Permalink to this headline">¶</a></h2>
<p>Zero-Noise-Extrapolation (ZNE), introduced concurrently in <a class="reference internal" href="#li2017" id="id9"><span>[Li2017]</span></a> and <a class="reference internal" href="#temme2016" id="id10"><span>[Temme2016]</span></a>, utilises
differing effective device noise levels to perform error correction. In particular,
the results of a computation at a variety of noise levels are used to extrapolate to the
zero noise limit. This approach acknowledges the difficulty in reducing noise levels,
but exploits our ability to increase them. As such, there are two selections to be made
when performing ZNE:</p>
<ul class="simple">
<li><p>The means by which the effective noise levels will be varied.</p></li>
<li><p>The method of extrapolation to use to recover the zero noise limit.</p></li>
</ul>
<p>Several options exist in both case.
Here we will focus on digital ZNE, as discussed in <a class="reference internal" href="#giurgica-tiron2020" id="id11"><span>[Giurgica-Tiron2020]</span></a>,
as a means to vary the noise level. Digital ZNE is based on the ability
to increase noise levels by increasing the number of gates executed. This contrasts with ‘analog’
approaches, which might, for example, alter noise levels by stretching or otherwise changing the
pulses acted on superconducting qubits. More specifically we increase
the effective noise by performing a folding operation on the circuit, which increases the
number of gates without affecting the unitary it implements. At their core these folding
methods use that, for a gate <span class="math notranslate nohighlight">\(G\)</span>, <span class="math notranslate nohighlight">\(G = G G^{-1} G\)</span>, and assume that making this
substitution has the affect of tripling the noise.</p>
<p>Extrapolation aims to recover an estimate of the expectation value of some observable,
given measured expectation values at the selection of noise levels facilitated by folding.
Note that the expectation values and the noise scaling factors are both real numbers. Given these
collections of values, and an anzats for the relation between the two, this reduces to a
regression problem. There are several ansatz provided by <code class="docutils literal notranslate"><span class="pre">qermit</span></code>. Each may have its
advantages depending on: the device, dominant noise channel, etc.</p>
<p>Generators for Zero-Noise-Extrapolation <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> objects are available in
the <code class="docutils literal notranslate"><span class="pre">qermit.zero_noise_extrapolation</span></code> <a class="reference external" href="https://cqcl.github.io/qermit/zero_noise_extrapolation.html">module</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qermit.zero_noise_extrapolation</span> <span class="kn">import</span> <span class="n">gen_ZNE_MitEx</span>
<span class="kn">from</span> <span class="nn">pytket.extensions.qiskit</span> <span class="kn">import</span> <span class="n">IBMQEmulatorBackend</span>
<span class="kn">from</span> <span class="nn">pytket.extensions.qiskit.backends.ibm</span> <span class="kn">import</span> <span class="n">_rebase_pass</span>

<span class="n">zne_mitex</span> <span class="o">=</span> <span class="n">gen_ZNE_MitEx</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="n">casablanca_backend</span><span class="p">,</span> <span class="n">rebase_pass</span><span class="o">=</span><span class="n">_rebase_pass</span><span class="p">,</span> <span class="n">noise_scaling_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="n">zne_mitex</span><span class="o">.</span><span class="n">get_task_graph</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/zne_taskgraph.png" src="_images/zne_taskgraph.png" />
<p>Here the three inputs are: <code class="docutils literal notranslate"><span class="pre">backend</span></code>, the backend on which the circuits will
be run; <code class="docutils literal notranslate"><span class="pre">rebase_pass</span></code>, a rebase pass which rebases to the gates native to the
backend; and <code class="docutils literal notranslate"><span class="pre">noise_scaling_list</span></code>, a list of integer multiples by which the
noise will be scaled. For each noise scaling value a different <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object is
constructed. Let’s construct a test case with expected value 1.0 and run the
error-mitigation <code class="docutils literal notranslate"><span class="pre">MitEx</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">PauliExpBox</span><span class="p">,</span> <span class="n">Qubit</span>
<span class="kn">from</span> <span class="nn">pytket.passes</span> <span class="kn">import</span> <span class="n">DecomposeBoxes</span>
<span class="kn">from</span> <span class="nn">pytket.pauli</span> <span class="kn">import</span> <span class="n">Pauli</span><span class="p">,</span> <span class="n">QubitPauliString</span>
<span class="kn">from</span> <span class="nn">pytket.utils</span> <span class="kn">import</span> <span class="n">QubitPauliOperator</span>

<span class="kn">from</span> <span class="nn">qermit</span> <span class="kn">import</span> <span class="n">ObservableTracker</span><span class="p">,</span> <span class="n">AnsatzCircuit</span><span class="p">,</span> <span class="n">SymbolsDict</span><span class="p">,</span> <span class="n">ObservableExperiment</span>


<span class="n">peb_xyz</span> <span class="o">=</span> <span class="n">PauliExpBox</span><span class="p">([</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">],</span> <span class="mf">0.25</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">DecomposeBoxes</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<span class="n">qubit_pauli_string</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">(</span>
    <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">]</span>
<span class="p">)</span>
<span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">AnsatzCircuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">SymbolsDict</span><span class="p">())</span>

<span class="n">exp</span> <span class="o">=</span> <span class="p">[</span><span class="n">ObservableExperiment</span><span class="p">(</span><span class="n">ansatz_circuit</span><span class="p">,</span> <span class="n">ObservableTracker</span><span class="p">(</span><span class="n">QubitPauliOperator</span><span class="p">({</span><span class="n">qubit_pauli_string</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})))]</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">zne_mitex</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{(</span><span class="n">Znode</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">Znode</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">Znode</span><span class="p">[</span><span class="mi">6</span><span class="p">]):</span> <span class="mf">0.897650000000000</span><span class="p">}]</span>
</pre></div>
</div>
<p>There are many customisation options available when using the zero-noise-extrapolation <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> generator
in <code class="docutils literal notranslate"><span class="pre">qermit</span></code>, all can be seen via the documentation.
The type of folding used for creating digitally noisier circuits can be specified via the
<code class="docutils literal notranslate"><span class="pre">_folding_type</span></code> keyword argument. This expects a <code class="docutils literal notranslate"><span class="pre">Folding</span></code> object, which default has support
for <code class="docutils literal notranslate"><span class="pre">gate</span></code> folding and <code class="docutils literal notranslate"><span class="pre">circuit</span></code> folding.
The fit used to extrapolate results can be specified via the <code class="docutils literal notranslate"><span class="pre">_fit_type</span></code> keyword argument.
This expects a <code class="docutils literal notranslate"><span class="pre">Fit</span></code> object, which default has support for a variety of fits.</p>
</div>
<div class="section" id="clifford-circuit-learning-and-clifford-data-regression-in-qermit">
<h2>Clifford-Circuit-Learning and Clifford-Data-Regression in <code class="docutils literal notranslate"><span class="pre">qermit</span></code><a class="headerlink" href="#clifford-circuit-learning-and-clifford-data-regression-in-qermit" title="Permalink to this headline">¶</a></h2>
<p>Correcting device noise typically requires some characterisation of what the noise is, while characterising
noise typically requires an understanding of what data would look like <em>without</em> noise.</p>
<p>Clifford-Circuit-Learning uses quantum circuits composed primarily of Clifford gates to characterise and correct
for device noise. As such circuits can be efficiently simulated classically this approach has viable scalability.</p>
<p>Given some experiment circuit to run on some device, a set of state circuits are generated for characterisation. Each
state circuit is constructed such that it is structurally similar to the experiment circuit, but near Clifford
so that it retains the feature of being efficiently simluated classically. In this method, such near Clifford circuits are
generated by substituting non-Clifford gates in the experiment Circuit with randomly sampled Clifford gates
from a biased distribution.</p>
<p>For each state circuit the ideal expectation value is calculated with a simulator for the desired observable, while the noisy expectation value
is calculated by running the circuit on the target device. These results are then used to construct
a model for the noise free value of the observable for states in the vicinity of the state the experiment circuit produces. The original experiment
circuit is then run on the device and its observable estimate corrected by the model.</p>
<p>In this sense, “Clifford-Circuit-Learning” refers to the general noise characterisation approach defined by
efficiently simulated classically Clifford circuits and “Clifford-Data-Regression” refers to the noise correction
technique used here.</p>
<p>Generators for Clifford-Data-Regression <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> objects are available in the <code class="docutils literal notranslate"><span class="pre">qermit.clifford_noise_characterisation</span></code> <a class="reference external" href="https://cqcl.github.io/qermit/clifford_noise_characterisation.html">module</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qermit.clifford_noise_characteisation</span> <span class="kn">import</span> <span class="n">gen_CDR_MitEx</span>
<span class="kn">from</span> <span class="nn">pytket.extensions.qiskit</span> <span class="kn">import</span> <span class="n">AerBackend</span><span class="p">,</span> <span class="n">IBMQBackend</span>


<span class="n">noisy_backend</span> <span class="o">=</span> <span class="n">IBMQBackend</span><span class="p">(</span>
  <span class="s2">&quot;ibmq_casablanca&quot;</span><span class="p">,</span>
  <span class="n">hub</span><span class="o">=</span><span class="s1">&#39;partner-cqc&#39;</span><span class="p">,</span>
  <span class="n">group</span><span class="o">=</span><span class="s1">&#39;internal&#39;</span><span class="p">,</span>
  <span class="n">project</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">noiseless_backend</span> <span class="o">=</span> <span class="n">AerBackend</span><span class="p">()</span>

<span class="n">cdr_mitex</span> <span class="o">=</span> <span class="n">gen_CDR_MitEx</span><span class="p">(</span><span class="n">device_backend</span> <span class="o">=</span> <span class="n">noisy_backend</span><span class="p">,</span>
                      <span class="n">simulator_backend</span> <span class="o">=</span> <span class="n">noiseless_backend</span><span class="p">,</span>
                      <span class="n">n_non_cliffords</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                      <span class="n">n_pairs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                      <span class="n">total_state_circuits</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">cdr_mitex</span><span class="o">.</span><span class="n">get_task_graph</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/cdr_taskgraph.png" src="_images/cdr_taskgraph.png" />
<p>We have avoided decomposing all graph nodes before viewing in this case as
there are many nodes required to complete this method (run <code class="docutils literal notranslate"><span class="pre">cdr_mitex.decompose_TaskGraph_nodes()</span></code>
before viewing if interested).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">device_backend</span></code> argument defines the <code class="docutils literal notranslate"><span class="pre">Backend</span></code> all noisy state circuit results and the actual
experiment results are retrieved and calculated from. The <code class="docutils literal notranslate"><span class="pre">simulator_backend</span></code> argument
defines the <code class="docutils literal notranslate"><span class="pre">Backend</span></code> all noiseless state circuit results and retrieved and calculated from.
The <code class="docutils literal notranslate"><span class="pre">n_non_cliffords</span></code> arguments defines the number of non-Clifford gates in the produced state circuits
for characterisation. In this construction, state circuits are generated via a Markov Chain
Monte Carlo technique by making small modifications to other state circuits -  the <code class="docutils literal notranslate"><span class="pre">n_pairs</span></code> argument
defines the number of non-Clifford state circuit gates converted to Clifford and vice versa (essentially
the ‘distance’ between generated state circuits). The <code class="docutils literal notranslate"><span class="pre">total_state_circuits</span></code> argument defines the total
number of state circuits constructed for characterisation.</p>
<p>These parameters give a large space for optimising the performance of the given method.
Furthermore, some keyword arguments allow even more customisation.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">model</span></code> keyword argument defines the model produced by the characterisation data
and expects a <code class="docutils literal notranslate"><span class="pre">_BaseExCorrectModel</span></code> object.
It is by default set to model a linear relationship between noisy and noiseless expectation values, but
the <code class="docutils literal notranslate"><span class="pre">_PolyCDRCorect</span></code> class can be used to define other relationships.</p>
<p>In <a class="reference internal" href="#czarnik2020" id="id14"><span>[Czarnik2020]</span></a>, a Metropolis-Hastings rule is used to accept or reject state circuits
from the characterisation data. The likelihood function used in this rule can be
defined with the <code class="docutils literal notranslate"><span class="pre">LikelihoodFunction</span></code> keyword argument, which expects a <code class="docutils literal notranslate"><span class="pre">LikelihoodFunction</span></code> object.
The relationship between performance and choice of <code class="docutils literal notranslate"><span class="pre">LikelihoodFunction</span></code> is expected
to be closely linked to the Circuits run, and so by default the likelihood function is set to
accept all results. Be aware that as <code class="docutils literal notranslate"><span class="pre">qermit</span></code> does not support loops currently, this process
is only run after device execution and so if any state circuits are not accepted, no replacement
will be found and so the total number of circuits used in characteriastion will be fewer
than as originally specified.</p>
<p>Lets test with a basic example with expected result 1.0.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">PauliExpBox</span><span class="p">,</span> <span class="n">Qubit</span>
<span class="kn">from</span> <span class="nn">pytket.passes</span> <span class="kn">import</span> <span class="n">DecomposeBoxes</span>
<span class="kn">from</span> <span class="nn">pytket.pauli</span> <span class="kn">import</span> <span class="n">Pauli</span>

<span class="n">peb_xyz</span> <span class="o">=</span> <span class="n">PauliExpBox</span><span class="p">([</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">],</span> <span class="mf">0.25</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">DecomposeBoxes</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Qubit</span>
<span class="kn">from</span> <span class="nn">pytket.pauli</span> <span class="kn">import</span> <span class="n">QubitPauliString</span><span class="p">,</span> <span class="n">Pauli</span>  <span class="c1"># type: ignore</span>
<span class="kn">from</span> <span class="nn">pytket.utils</span> <span class="kn">import</span> <span class="n">QubitPauliOperator</span>
<span class="kn">from</span> <span class="nn">qermit</span> <span class="kn">import</span> <span class="n">ObservableTracker</span><span class="p">,</span> <span class="n">AnsatzCircuit</span><span class="p">,</span> <span class="n">SymbolsDict</span><span class="p">,</span> <span class="n">ObservableExperiment</span>

<span class="n">qubit_pauli_string</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">(</span>
    <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">]</span>
<span class="p">)</span>
<span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">AnsatzCircuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">SymbolsDict</span><span class="p">())</span>

<span class="n">exp</span> <span class="o">=</span> <span class="p">[</span><span class="n">ObservableExperiment</span><span class="p">(</span><span class="n">ansatz_circuit</span><span class="p">,</span> <span class="n">ObservableTracker</span><span class="p">(</span><span class="n">QubitPauliOperator</span><span class="p">({</span><span class="n">qubit_pauli_string</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})))]</span>
<span class="n">cdr_results</span> <span class="o">=</span> <span class="n">cdr_mitex</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cdr_results</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{(</span><span class="n">Zq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Zq</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Zq</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span> <span class="mf">0.822882253534080</span><span class="p">}]</span>
</pre></div>
</div>
<p>For comparison we can run the same experiment without error-mitigation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qermit</span> <span class="kn">import</span> <span class="n">MitEx</span>
<span class="n">mitex</span> <span class="o">=</span> <span class="n">MitEx</span><span class="p">(</span><span class="n">noisy_backend</span><span class="p">)</span>
<span class="n">exp</span> <span class="o">=</span> <span class="p">[</span><span class="n">ObservableExperiment</span><span class="p">(</span><span class="n">ansatz_circuit</span><span class="p">,</span> <span class="n">ObservableTracker</span><span class="p">(</span><span class="n">QubitPauliOperator</span><span class="p">({</span><span class="n">qubit_pauli_string</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})))]</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">mitex</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{(</span><span class="n">Zq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Zq</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Zq</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span> <span class="mf">0.729000000000000</span><span class="p">}]</span>
</pre></div>
</div>
<p>For the basic example constructed, fairly small 2000 shots and the ibmq_casablanca device available
through IBMQ, we see that the error-mitigated expectation value is closer to the expected value 1.0 than
without error-mitigation.</p>
<p>For combining schemes, the <code class="docutils literal notranslate"><span class="pre">StatesSimulatorMitex</span></code> keyword argument defines the <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object
for noiseless simluation of all state circuits, the <code class="docutils literal notranslate"><span class="pre">StatesDeviceMitex</span></code> keyword argument
defines the <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object for device executions of all state circuits, and the <code class="docutils literal notranslate"><span class="pre">ExperimentMitex</span></code> object
defines the <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object all experiment circuits are executed on.</p>
</div>
<div class="section" id="depolarisation-factor-supression-for-nearest-clifford-in-qermit">
<h2>Depolarisation-Factor-Supression-For-Nearest-Clifford in <code class="docutils literal notranslate"><span class="pre">qermit</span></code><a class="headerlink" href="#depolarisation-factor-supression-for-nearest-clifford-in-qermit" title="Permalink to this headline">¶</a></h2>
<p>This method estimates the averaged incoherent noise component affecting the entire circuit structure
and reduces its effect on computing expectation values. The main advantage of DFSC is that it does
not require significant quantum resource overhead (no additional ancillas and no increased depth)
and relies on efficient classical processing. This error-mitigation technique trades-off a finer-grained
noise characterisation for scalability (i.e reduced computational resources).</p>
<p>The effect of an incoherent Pauli noise channel when computing expectation values of Pauli operators
for a target state is to scale the exact expected value by a factor that depends on the i) noise channel
and ii) Pauli observable.</p>
<p>DFSC estimates this factor by assuming that a Clifford circuit derived from the structure of the target
quantum circuit will incur similar levels of incoherent noise. This factor results from quantum hardware
evaluation of the Pauli observable’s expected value with respect to a state produced by the Clifford circuit
acting on a positive eigenstate of a forwarded Pauli operator given by the adjoint action of the Clifford
unitary on the target Pauli observable.</p>
<p>The freedom in the choice of eigenstate can be used to extend the present method to allow finer error
mitigation at the expense of increased computational resources.</p>
<p>The DFSC method will be most useful when the accumulation of errors through a circuit incurs a loss of
purity in the state preparation and incoherent errors dominate. It may be used, for example, in a
variational algorithm to adaptively account for these types of errors within the optimisation loop using
minimal additional quantum compute time.</p>
<p>Generators for Depolarisation-Factor-Supression-For-Nearest-Clifford <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> objects are available
in the <code class="docutils literal notranslate"><span class="pre">qermit.clifford_noise_characterisation</span></code> <a class="reference external" href="https://cqcl.github.io/qermit/clifford_noise_characterisation.html">module</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qermit.clifford_noise_characterisation</span> <span class="kn">import</span> <span class="n">gen_DFSC_MitEx</span>
<span class="kn">from</span> <span class="nn">pytket.extensions.qiskit</span> <span class="kn">import</span> <span class="n">IBMQBackend</span>

<span class="n">casablanca_backend</span> <span class="o">=</span> <span class="n">IBMQEmulatorBackend</span><span class="p">(</span>
  <span class="s2">&quot;ibmq_casablanca&quot;</span><span class="p">,</span>
  <span class="n">hub</span><span class="o">=</span><span class="s1">&#39;partner-cqc&#39;</span><span class="p">,</span>
  <span class="n">group</span><span class="o">=</span><span class="s1">&#39;internal&#39;</span><span class="p">,</span>
  <span class="n">project</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">dfsc_mitex</span> <span class="o">=</span> <span class="n">gen_DFSC_MitEx</span><span class="p">(</span><span class="n">casablanca_backend</span><span class="p">)</span>
<span class="n">dfsc_mitex</span><span class="o">.</span><span class="n">get_task_graph</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/dfsc_taskgraph.png" src="_images/dfsc_taskgraph.png" />
<p>The DFSC <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> expects all non-Clifford gates to be parameterised via the <code class="docutils literal notranslate"><span class="pre">SymbolsDict</span></code>. Once again,
we construct an example that with expected value 1.0.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">PauliExpBox</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">,</span> <span class="n">fresh_symbol</span>
<span class="kn">from</span> <span class="nn">pytket.passes</span> <span class="kn">import</span> <span class="n">DecomposeBoxes</span>
<span class="kn">from</span> <span class="nn">pytket.pauli</span> <span class="kn">import</span> <span class="n">Pauli</span><span class="p">,</span> <span class="n">QubitPauliString</span>
<span class="kn">from</span> <span class="nn">pytket.utils</span> <span class="kn">import</span> <span class="n">QubitPauliOperator</span>

<span class="kn">from</span> <span class="nn">qermit</span> <span class="kn">import</span> <span class="n">ObservableTracker</span><span class="p">,</span> <span class="n">AnsatzCircuit</span><span class="p">,</span> <span class="n">SymbolsDict</span><span class="p">,</span> <span class="n">ObservableExperiment</span>

<span class="n">sym</span> <span class="o">=</span> <span class="n">fresh_symbol</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)</span>
<span class="n">peb_xyz</span> <span class="o">=</span> <span class="n">PauliExpBox</span><span class="p">([</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">],</span> <span class="n">sym</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">peb_xyz</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">DecomposeBoxes</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>


<span class="n">qubit_pauli_string</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">(</span>
        <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">]</span>
    <span class="p">)</span>
<span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">AnsatzCircuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">SymbolsDict</span><span class="o">.</span><span class="n">symbols_from_dict</span><span class="p">({</span><span class="n">sym</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">}))</span>

<span class="n">exp</span> <span class="o">=</span> <span class="p">[</span><span class="n">ObservableExperiment</span><span class="p">(</span><span class="n">ansatz_circuit</span><span class="p">,</span> <span class="n">ObservableTracker</span><span class="p">(</span><span class="n">QubitPauliOperator</span><span class="p">({</span><span class="n">qubit_pauli_string</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})))]</span>
<span class="n">dfsc_results</span> <span class="o">=</span> <span class="n">dfsc_mitex</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dfsc_results</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{(</span><span class="n">Zq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Zq</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Zq</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span> <span class="mf">0.848898216159496</span><span class="p">}]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> object returned by <code class="docutils literal notranslate"><span class="pre">gen_DFSC_MitEx</span></code> has both a characterisation and experiment stage.
The <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> characterisation is completed with can be specified with the <code class="docutils literal notranslate"><span class="pre">CharacterisationMitex</span></code> keyword argument.
The <code class="docutils literal notranslate"><span class="pre">MitEx</span></code> the experiment is completed with can be specified with the <code class="docutils literal notranslate"><span class="pre">ExperimentMitex</span></code> keyword argument.</p>
<dl class="citation">
<dt class="label" id="bonet-monroig2018"><span class="brackets"><a class="fn-backref" href="#id1">Bonet-Monroig2018</a></span></dt>
<dd><p>Bonet-Monroig, X., Sagastizabal, R., Singh, M., O’Brien, T.E., 2018. Low-cost error mitigation by symmetry verification. Phys. Rev. A 98, 062339 (2018).</p>
</dd>
<dt class="label" id="temme2016"><span class="brackets">Temme2016</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id5">2</a>,<a href="#id7">3</a>,<a href="#id10">4</a>)</span></dt>
<dd><p>Temme, K., Bravyi, S., Gambetta, J.M., 2016. error mitigation for short-depth quantum circuits.  Phys. Rev. Lett. 119, 180509 (2017).</p>
</dd>
<dt class="label" id="giurgica-tiron2020"><span class="brackets">Giurgica-Tiron2020</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id11">2</a>)</span></dt>
<dd><p>Giurgica-Tiron, T., Hindy, Y., LaRose, Ryan., Mari, A., Zeng, W.J., 2020, Digital zero noise extrapolation for quantum error mitigation. 2020 IEEE International Conference on Quantum Computing and Engineering (QCE), Denver, CO, USA, 2020.</p>
</dd>
<dt class="label" id="czarnik2020"><span class="brackets">Czarnik2020</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id14">2</a>)</span></dt>
<dd><p>Czarnik, P., Arrasmith, A., Coles, P.J., Cincio, L., 2020. error mitigation with Clifford quantum-circuit data. arXiv:2005.10189.</p>
</dd>
<dt class="label" id="li2017"><span class="brackets"><a class="fn-backref" href="#id9">Li2017</a></span></dt>
<dd><p>Li, Y., &amp; Benjamin, S. C. (2017). Efficient variational quantum simulator incorporating active error minimization. Physical Review X, 7(2), 021050.</p>
</dd>
<dt class="label" id="endo2018"><span class="brackets"><a class="fn-backref" href="#id6">Endo2018</a></span></dt>
<dd><p>Endo, S., Benjamin, S. C., &amp; Li, Y. (2018). Practical quantum error mitigation for near-future applications. Physical Review X, 8(3), 031027.</p>
</dd>
<dt class="label" id="strikis2020"><span class="brackets"><a class="fn-backref" href="#id8">Strikis2020</a></span></dt>
<dd><p>Strikis, A., Qin, D., Chen, Y., Benjamin, S. C., &amp; Li, Y. (2020). Learning-based quantum error mitigation. arXiv preprint arXiv:2005.07601.</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="manual_mitres.html" class="btn btn-neutral float-left" title="MitRes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020-2021 Cambridge Quantum Computing Ltd.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>